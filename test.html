<span style="background-color: rgb(255, 255, 255);"><!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Three.js draft</title>
<script src="Three.js"></script>
<script src="Controls/TrackballControls.js"></script>
<script src='Controls/DAT.GUI.min.js'></script>
<style type="text/css">
div#canvas-frame{
  border: none;
  cursor: auto;
  width: 100%;
  height: 100%;
  background-color: #EEEEEE;
}
</style>
<script>
  var renderer;
  function initThree() {
    width = document.getElementById('canvas-frame').clientWidth;
    height = document.getElementById('canvas-frame').clientHeight; 
    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.shadowMapEnabled = true;
    renderer.setSize(width, height );
    var last = new Date().getTime();
    document.getElementById('canvas-frame').appendChild(renderer.domElement);
    renderer.setClearColorHex(0xFFFFFF, 1.0);
  }

  //////////////////////////////////////////////////////////////////////////////////
  //    Camera Controls                                                           //
  ////////////////////////////////////////////////////////////////////////////////// 
  var camera;
  function initCamera() { 
    camera = new THREE.PerspectiveCamera( 45 , width / height , 1 , 10000 );
    camera.position.x = 1000;
    camera.position.y = 0;
    camera.position.z = 0;
    camera.up.x = 0;
    camera.up.y = 0;
    camera.up.z = 1;
    camera.lookAt( {x:0, y:0, z:0 } );
 
    controls = new THREE.TrackballControls( camera );

        controls.rotateSpeed = 2.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;

        controls.noZoom = false;
        controls.noPan = false;

        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;

        controls.keys = [ 65, 83, 68 ];
      }


    
  var scene;
  function initScene() {   
    scene = new THREE.Scene();
    scene.updateMatrixWorld(true);
  }
  var light;


  function initLight() {
    light = new THREE.DirectionalLight(0xFFFFFF, 1.0, 0);
    light.position.set( 100, 100, 200 );
    light.castShadow = true;
    scene.add(light);
  }

  var mouse = new THREE.Vector2(),
  projector = new THREE.Projector(),
  offset = new THREE.Vector3(),
  INTERSECTED,SELECTED;




  document.addEventListener( 'mousemove', onDocumentMouseMove, false );

  document.addEventListener( 'mousedown', onDocumentMouseDown, false );
  document.addEventListener( 'mouseup', onDocumentMouseUp, false );

  function onDocumentMouseMove( event ) {

      event.preventDefault();

      mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
      mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

      //

      var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
      projector.unprojectVector( vector, camera );

      var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );


      if ( SELECTED ) {

          var intersects = raycaster.intersectObject( plane );
          SELECTED.position.copy( intersects[ 0 ].point.sub( offset ) );
          return;

      }


      var intersects = raycaster.intersectObjects( Group,true );

      if ( intersects.length > 0 ) {

          if ( INTERSECTED != intersects[ 0 ].object.parent ) {

              if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

              INTERSECTED = intersects[ 0 ].object.parent;

              plane.position.copy( INTERSECTED.position );
              plane.lookAt( camera.position );

          }


      } else {

          if ( INTERSECTED )

          INTERSECTED = null;


      }

  }

  function onDocumentMouseDown( event ) {

      event.preventDefault();

      var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
      projector.unprojectVector( vector, camera );

      var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

      var intersects = raycaster.intersectObjects( Group,true );

      if ( intersects.length > 0 ) {

          controls.enabled = false;

          SELECTED = intersects[ 0 ].object.parent;

          var intersects = raycaster.intersectObject( plane );
          offset.copy( intersects[ 0 ].point ).sub( plane.position );


      }

  }

  function onDocumentMouseUp( event ) {

      event.preventDefault();

      controls.enabled = true;

      if ( INTERSECTED ) {

          plane.position.copy( INTERSECTED.position );

          SELECTED = null;

      }


  }


 var Group = [];
 var sphere = [];
 var vector = [];
 function initObject(){
     plane = new THREE.Mesh( new THREE.PlaneGeometry( 3000, 3000,8, 8 ), new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.25, transparent: true, wireframe:true } ) );
     plane.lookAt( camera.position );
     plane.visible = true;
     scene.add( plane );


     var C1 = new THREE.Mesh(new THREE.CylinderGeometry(200,200,400,100),new THREE.MeshBasicMaterial({color:0x111111,transparent:true,opacity:0.3}));
     C1.rotation.x = Math.PI/2;
     scene.add(C1);

     var C2 = new THREE.Mesh(new THREE.CylinderGeometry(130,130,400,100),new THREE.MeshBasicMaterial({color:0x111111, transparent:true,opacity:0.8}));
     C2.rotation.x = Math.PI/2;
     scene.add(C2);



    sphere[0] = new THREE.Mesh(
         new THREE.SphereGeometry(20,50,50),               
         new THREE.MeshLambertMaterial({color: 0xffff00}) 
          
    );
   vector[0] = new THREE.Vector3();

     sphere[1] = new THREE.Mesh(
         new THREE.SphereGeometry(20,50,50),               
         new THREE.MeshLambertMaterial({color: 0xff0000})

    );
   vector[1] = new THREE.Vector3();

     rx.push(0);
     ry.push(0);
     rz.push(0);
     sx.push(0);
     sy.push(500);
     sz.push(300);

    sphere[0].position.set(0,482,300);
    sphere[1].position.set(0,518,300);
    
    dimer = new THREE.Object3D();
    dimer.add(sphere[0]);
    dimer.add(sphere[1]);
    Group.push(dimer);
    scene.add(Group[0]);
     Group[0].name="Group[0]"

  }
      var k = 2;
      var kk = 1;
      var controlPanel = new function () {
        this.addDimers = function () {

            sphere[k] = new THREE.Mesh(
              new THREE.SphereGeometry(20,50,50),
              new THREE.MeshLambertMaterial({color: 0xffff00}) 
            );
            vector[k] = new THREE.Vector3();

            sphere[k + 1] = new THREE.Mesh(
              new THREE.SphereGeometry(20,50,50),
              new THREE.MeshLambertMaterial({color: 0xff0000})
            );
            vector[k + 1] = new THREE.Vector3();

            rx.push(0);
            ry.push(0);
            rz.push(0);
            sx.push(0);
            sy.push(500);
            sz.push(300);
    sphere[k].position.set(0,482,300);
    sphere[k + 1].position.set(0,518,300);


    dimer2 = new THREE.Object3D();
    dimer2.add(sphere[k]);
    dimer2.add(sphere[k + 1]);
    Group.push(dimer2);
    scene.add(Group[kk]);
            Group[kk].name="Group[kk]"
    kk++;
    k += 2;
        }
      }


    var gui = new dat.GUI({width: 160});
    gui.add(controlPanel, 'addDimers');


  var rx = [];
  var ry = [];
  var rz = [];

  var sx = [];
  var sy = [];
  var sz = [];


  function collisionDetection( m, n){

          var mod = new THREE.Vector3(vector[m].x - vector[n].x, vector[m].y - vector[n].y, vector[m].z - vector[n].z);
          if (mod.length() <= 20) {
              alert(m + "," + n + " crashed");
          }

  }


  function animate(){

    renderer.clear();
    renderer.render(scene,camera);
    controls.update();

/*      for(var i = 0; i < Group.length; i++) {
          sx[i] += parseInt(12 * Math.random() - 6);
          sy[i] += parseInt(12 * Math.random() - 6);
          sz[i] += parseInt(12 * Math.random() - 6);
          rx[i] += (0.4 * Math.random() - 0.2);
          ry[i] += (0.4 * Math.random() - 0.2);
          rz[i] += (0.4 * Math.random() - 0.2);

          Group[i].rotation.set(rx[i], ry[i], rz[i]);
          Group[i].position.set(sx[i], sy[i], sz[i]);

          vector[2 * i].getPositionFromMatrix(sphere[2 * i].matrixWorld);

          vector[2 * i + 1].getPositionFromMatrix(sphere[2 * i + 1].matrixWorld);

          if(Group.length > 1) {
                  for(var j = i; j < Group.length - 1; j++) {
                      collisionDetection(2 * i, 2 * j + 2);
                      collisionDetection(2 * i, 2 * j + 3);
                      collisionDetection(2 * i + 1, 2 * j + 2);
                      collisionDetection(2 * i + 1, 2 * j + 3);
                  }

          }
      }
*/
      requestAnimationFrame(animate);

        
  }






  function threeStart() {
    initThree();
    initCamera();
    initScene();   
    initLight();
    initObject();
    animate();

  }






</script>
</head>
 
<body onload="threeStart();">
<div id="canvas-frame"></div>
</body>
</html></span>